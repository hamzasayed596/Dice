<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dice Roller</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body 
        {
            background: linear-gradient(135deg, #0a1929, #0c1e34);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            color: white;
            position: relative;
        }
        canvas 
        {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100%;
            height: 100%;
        }
        #ui-container
        {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            text-align: center;
            padding: 30px;
            width: 380px;
            background: rgba(10, 15, 30, 0.9);
            backdrop-filter: blur(12px);
            border-radius: 25px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 20px;
            transition: all 0.3s ease;
        }
        .header 
        {
            margin-bottom: 15px;
        }
        .header h1 
        {
            font-size: 2.5rem;
            margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
            background: linear-gradient(to right, #00c9ff, #92fe9d);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-weight: 700;
            letter-spacing: 1px;
        }
        .header p 
        {
            font-size: 1.1rem;
            opacity: 0.85;
            color: #a0d2ff;
        }
        #result-container 
        {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .die-result 
        {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 18px;
            padding: 20px 30px;
            font-size: 3.2rem;
            font-weight: 900;
            min-width: 100px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.2);
            opacity: 0;
            transform: scale(0);
            transition: all 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }
        .die-result:before 
        {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, rgba(255,255,255,0.05), rgba(255,255,255,0.15));
            border-radius: 18px;
            z-index: -1;
        }
        .die-result:nth-child(1) 
        { 
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.25), rgba(255, 107, 107, 0.1));
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.3);
        }
        .die-result:nth-child(2) { 
            background: linear-gradient(135deg, rgba(107, 255, 161, 0.25), rgba(107, 255, 161, 0.1));
            box-shadow: 0 8px 25px rgba(107, 255, 161, 0.3);
        }
        .die-result.pop {
            animation: popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.5); }
            60% { opacity: 1; transform: scale(1.15); }
            100% { opacity: 1; transform: scale(1); }
        }
        #total {
            font-size: 2.3rem;
            font-weight: 700;
            margin: 10px 0;
            color: #ffd166;
            text-shadow: 0 0 20px rgba(255, 209, 102, 0.7);
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease-out 0.2s;
            letter-spacing: 1px;
        }
        #total.show {
            animation: dropIn 0.5s ease-out forwards;
        }
        @keyframes dropIn {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 15px 0;
        }
        .controls-row {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        button {
            background: linear-gradient(45deg, #00c9ff, #92fe9d);
            color: #0a1929;
            border: none;
            border-radius: 50px;
            padding: 16px 30px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            outline: none;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(0, 201, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex: 1;
            position: relative;
            overflow: hidden;
            z-index: 2;
        }
        button:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, rgba(255,255,255,0.2), transparent);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s;
        }
        button:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 201, 255, 0.6);
        }
        button:hover:before {
            opacity: 1;
        }
        button:active {
            transform: translateY(2px);
            box-shadow: 0 6px 20px rgba(0, 201, 255, 0.4);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 8px 25px rgba(0, 201, 255, 0.2);
        }
        button.secondary {
            background: linear-gradient(45deg, #4e54c8, #8f94fb);
        }
        #dice-count {
            background: rgba(255, 255, 255, 0.12);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            padding: 16px 25px;
            color: white;
            font-size: 18px;
            font-weight: 600;
            outline: none;
            cursor: pointer;
            text-align: center;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            flex: 1;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 20px center;
            background-size: 20px;
        }
        #dice-count:hover, #dice-count:focus {
            border-color: #00c9ff;
            box-shadow: 0 0 0 3px rgba(0, 201, 255, 0.3);
        }
        #dice-count option {
            background: #1a1a2e;
            padding: 10px;
        }
        #instructions {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 15px;
            opacity: 0.8;
            z-index: 10;
            background: rgba(0, 0, 0, 0.35);
            padding: 10px 20px;
            border-radius: 20px;
            width: max-content;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        #power-meter {
            width: 100%;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            margin-top: 15px;
            overflow: hidden;
            display: none;
            position: relative;
        }
        #power-level {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4e54c8, #8f94fb, #ff8a00, #ff416c);
            border-radius: 6px;
            transition: width 0.1s;
        }
        
        #stats-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(10, 15, 30, 0.85);
            backdrop-filter: blur(12px);
            border-radius: 18px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.15);
            width: 280px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .stat-card {
            background: rgba(30, 35, 60, 0.6);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .stat-card:hover {
            transform: translateY(-3px);
            background: rgba(40, 45, 70, 0.8);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffd166;
            margin: 5px 0;
        }
        
        .stat-label {
            font-size: 0.95rem;
            opacity: 0.85;
        }
        
        .sun-rays {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 80% 10%, rgba(255, 255, 200, 0.15), transparent 60%);
            pointer-events: none;
            z-index: 0;
            animation: rayRotate 30s infinite linear;
        }
        
        @keyframes rayRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .floating {
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
            100% { transform: translateY(0px); }
        }
        
        #toggle-ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 20;
            background: rgba(10, 15, 30, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            font-size: 1.5rem;
            display: none;
        }
        
        #toggle-ui:hover {
            background: rgba(40, 45, 70, 0.9);
            transform: scale(1.1);
        }
        
        @media (max-width: 1100px) {
            #ui-container {
                left: -400px;
            }
            #ui-container.open {
                left: 20px;
            }
            #toggle-ui {
                display: flex;
            }
        }
        
        @media (max-width: 768px) {
            #ui-container {
                width: calc(100% - 40px);
                top: auto;
                bottom: 20px;
                left: 50%;
                transform: translate(-50%, 0);
            }
            #ui-container.open {
                left: 50%;
                transform: translate(-50%, 0);
            }
            .header h1 {
                font-size: 2rem;
            }
            .die-result {
                font-size: 2.5rem;
                padding: 18px 25px;
                min-width: 85px;
            }
            #total {
                font-size: 2rem;
            }
            button {
                padding: 14px 20px;
                font-size: 16px;
            }
            #instructions {
                font-size: 13px;
                bottom: 15px;
                padding: 8px 15px;
            }
            #stats-panel {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
                top: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="sun-rays"></div>
    
    <div id="ui-container">
        <div class="header floating">
            <h1><i class="fas fa-dice"></i> Dice</h1>
            <p>Just roll the dice</p>
        </div>
        
        <div id="result-container">
            <div class="die-result">0</div>
            <div class="die-result">0</div>
        </div>
        
        <div id="total">Total: <span id="total-value">0</span></div>
        
        <div class="controls">
            <div class="controls-row">
                <button id="throwButton">
                    <i class="fas fa-dice"></i> Roll Dice
                </button>
                <button id="resetButton" class="secondary">
                    <i class="fas fa-sync-alt"></i> Reset
                </button>
            </div>
            <div class="controls-row">
                <select id="dice-count">
                    <option value="1">1 Die</option>
                    <option value="2" selected>2 Dice</option>
                </select>
            </div>
        </div>
        <div id="power-meter">
            <div id="power-level"></div>
        </div>
    </div>
    
    <div id="instructions">Click "Roll Dice" or press Spacebar • Hold Space for more power</div>
    
    <div id="stats-panel">
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Total Rolls</div>
                <div id="total-rolls" class="stat-value">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Dice Rolled</div>
                <div id="total-dice" class="stat-value">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Highest Roll</div>
                <div id="highest-roll" class="stat-value">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Average Roll</div>
                <div id="average-roll" class="stat-value">0.00</div>
            </div>
        </div>
    </div>
    
    <div id="toggle-ui">
        <i class="fas fa-bars"></i>
    </div>

    <script type="module">
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 30, 100);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 18);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        const world = new CANNON.World();
        world.gravity.set(0, -15, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;
        
        function createFaceMaterial(number) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(256, 256, 50, 256, 256, 256);
            gradient.addColorStop(0, '#2c3e50');
            gradient.addColorStop(1, '#1a2530');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 20;
            ctx.strokeRect(10, 10, 492, 492);
            
            ctx.fillStyle = '#ecf0f1';
            const dotPositions = getDotPositions(number);
            const dotSize = 60;
            
            for (const pos of dotPositions) {
                ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
                ctx.shadowBlur = 20;
                
                ctx.beginPath();
                ctx.arc(256 + pos.x * 100, 256 + pos.y * 100, dotSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(256 + pos.x * 100 - dotSize/3, 256 + pos.y * 100 - dotSize/3, dotSize/3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ecf0f1';
            }
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            return new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.2,
                metalness: 0.7,
                emissive: new THREE.Color(0x111111),
                emissiveIntensity: 0.3
            });
        }
        
    function getDotPositions(number) {
        const positions = [];
        const spread = 1.25;
        
        switch(number) {
            case 1:
                positions.push({x: 0, y: 0});
                break;
            case 2:
                positions.push({x: -spread, y: -spread});
                positions.push({x: spread, y: spread});
                break;
            case 3:
                positions.push({x: -spread, y: -spread});
                positions.push({x: 0, y: 0});
                positions.push({x: spread, y: spread});
                break;
            case 4:
                positions.push({x: -spread, y: -spread});
                positions.push({x: spread, y: -spread});
                positions.push({x: -spread, y: spread});
                positions.push({x: spread, y: spread});
                break;
            case 5:
                positions.push({x: -spread, y: -spread});
                positions.push({x: spread, y: -spread});
                positions.push({x: 0, y: 0});
                positions.push({x: -spread, y: spread});
                positions.push({x: spread, y: spread});
                break;
            case 6:
                positions.push({x: -spread, y: -spread});
                positions.push({x: spread, y: -spread});
                positions.push({x: -spread, y: 0});
                positions.push({x: spread, y: 0});
                positions.push({x: -spread, y: spread});
                positions.push({x: spread, y: spread});
                break;
        }
        return positions;
    }
        function createDie() {
            const boxGeometry = new THREE.BoxGeometry(2.8, 2.8, 2.8, 8, 8, 8);
            const positionAttribute = boxGeometry.getAttribute('position');
            const vertex = new THREE.Vector3();
            const normal = new THREE.Vector3();
            const chamferSize = 0.18;
            
            for (let i = 0; i < positionAttribute.count; i++) {
                vertex.fromBufferAttribute(positionAttribute, i);
                normal.copy(vertex).normalize();
                vertex.add(normal.multiplyScalar(-chamferSize));
                positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }
            positionAttribute.needsUpdate = true;
            boxGeometry.computeVertexNormals();
            
            const materials = [
                createFaceMaterial(1), 
                createFaceMaterial(6), 
                createFaceMaterial(2), 
                createFaceMaterial(5), 
                createFaceMaterial(3), 
                createFaceMaterial(4) 
            ];
            
            const die = new THREE.Mesh(boxGeometry, materials);
            die.castShadow = true;
            die.receiveShadow = true;
            
            const dieShape = new CANNON.Box(new CANNON.Vec3(1.4 - chamferSize, 1.4 - chamferSize, 1.4 - chamferSize));
            const dieBody = new CANNON.Body({
                mass: 1.2,
                shape: dieShape,
                material: new CANNON.Material({ 
                    friction: 0.4,
                    restitution: 0.3
                })
            });
            
            return { mesh: die, body: dieBody };
        }
        
        function createEndlessGrass() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#2a7a2a';
            ctx.fillRect(0, 0, 512, 512);
            
            for (let i = 0; i < 3000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const length = 5 + Math.random() * 15;
                const width = 1 + Math.random() * 2;
                
                const greenShade = 120 + Math.floor(Math.random() * 60);
                ctx.fillStyle = `rgb(40, ${greenShade}, 40)`;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + width, y);
                ctx.lineTo(x + width/2, y - length);
                ctx.closePath();
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(30, 30);
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                map: texture,
                roughness: 0.9,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 30, 30);
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.position.y = -5;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
            
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape,
                material: new CANNON.Material({ 
                    friction: 0.6,
                    restitution: 0.2
                }),
            });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            groundBody.position.y = -5;
            world.addBody(groundBody);
            
            createFlowers();
            
            return groundMesh;
        }
        
        function createFlowers() {
            const flowerColors = [
                '#FF69B4', '#FF1493', '#FF6347', '#FF4500', '#FFA500', 
                '#FFD700', '#FFEC8B', '#FFB6C1', '#FFC0CB', '#FF69B4'
            ];
            
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < 150; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                const y = -4.9;
                
                positions.push(x, y, z);
                
                const color = new THREE.Color(flowerColors[Math.floor(Math.random() * flowerColors.length)]);
                colors.push(color.r, color.g, color.b);
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: false
            });
            
            const flowers = new THREE.Points(geometry, material);
            scene.add(flowers);
            
            return flowers;
        }
        
        function createSky() {
            const skyGeometry = new THREE.SphereGeometry(200, 64, 64);
            
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87ceeb,
                side: THREE.BackSide
            });
            
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            const cloudGeometry = new THREE.SphereGeometry(199, 64, 64);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide
            });
            
            const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(clouds);
            
            const sunGeometry = new THREE.SphereGeometry(4, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff99 });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(50, 50, -50);
            scene.add(sun);
            
            return sky;
        }
        
        function createMountains() {
            const mountainGroup = new THREE.Group();
            
            for (let i = 0; i < 8; i++) {
                const distance = 100 + Math.random() * 50;
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                const height = 15 + Math.random() * 30;
                const width = 20 + Math.random() * 30;
                const depth = 10 + Math.random() * 20;
                
                const mountainGeometry = new THREE.ConeGeometry(width, height, 8, 1, true);
                const mountainMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4a6b8a,
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountain.position.set(x, -5 + height/2, z);
                mountain.rotation.y = Math.random() * Math.PI * 2;
                mountainGroup.add(mountain);
            }
            
            scene.add(mountainGroup);
            return mountainGroup;
        }
        
        function createButterflies() {
            const butterflyGroup = new THREE.Group();
            const butterflyColors = [
                0xff69b4, 0x00c9ff, 0x92fe9d, 0xffd166, 0x8f94fb
            ];
            
            for (let i = 0; i < 12; i++) {
                const butterflyGeometry = new THREE.BoxGeometry(0.5, 0.1, 1.2);
                const butterflyMaterial = new THREE.MeshStandardMaterial({ 
                    color: butterflyColors[i % butterflyColors.length],
                    roughness: 0.3,
                    metalness: 0.2
                });
                
                const butterfly = new THREE.Mesh(butterflyGeometry, butterflyMaterial);
                
                butterfly.position.set(
                    (Math.random() - 0.5) * 80,
                    -2 + Math.random() * 15,
                    (Math.random() - 0.5) * 80
                );
                
                butterflyGroup.add(butterfly);
            }
            
            scene.add(butterflyGroup);
            return butterflyGroup;
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(15, 30, 15);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 1;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.bias = -0.0001;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xffdd99, 1.5, 100);
            pointLight.position.set(0, 20, 0);
            pointLight.castShadow = true;
            scene.add(pointLight);

            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x2a7a2a, 0.7);
            scene.add(hemiLight);

            const rimLight = new THREE.DirectionalLight(0x4d7fff, 0.8);
            rimLight.position.set(-15, 15, -15);
            scene.add(rimLight);
            
            return directionalLight;
        }
        
        const resultContainer = document.getElementById('result-container');
        const totalEl = document.getElementById('total');
        const totalValueEl = document.getElementById('total-value');
        const throwButton = document.getElementById('throwButton');
        const resetButton = document.getElementById('resetButton');
        const diceCountEl = document.getElementById('dice-count');
        const totalRollsEl = document.getElementById('total-rolls');
        const totalDiceEl = document.getElementById('total-dice');
        const highestRollEl = document.getElementById('highest-roll');
        const averageRollEl = document.getElementById('average-roll');
        const powerMeter = document.getElementById('power-meter');
        const powerLevel = document.getElementById('power-level');
        const toggleUiBtn = document.getElementById('toggle-ui');
        
        let dice = [];
        let isRolling = false;
        let results = [];
        let totalRolls = 0;
        let totalDiceRolled = 0;
        let highestRoll = 0;
        let totalRollSum = 0;
        let diceCount = 2;
        let powerCharge = 0;
        let powerChargeInterval;
        let butterflies;
        
        function initDice() {
            dice.forEach(die => {
                scene.remove(die.mesh);
                world.removeBody(die.body);
            });
            dice = [];
            
            for (let i = 0; i < diceCount; i++) {
                const die = createDie();
                
                const radius = diceCount === 1 ? 0 : 3;
                const angle = (i / diceCount) * Math.PI * 2;
                die.body.position.set(
                    Math.cos(angle) * radius,
                    5 + Math.random() * 2,
                    Math.sin(angle) * radius
                );
                
                die.body.quaternion.setFromEuler(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                scene.add(die.mesh);
                world.addBody(die.body);
                dice.push(die);
            }
            
            const dieResults = document.querySelectorAll('.die-result');
            dieResults.forEach((el, i) => {
                if (i < diceCount) {
                    el.style.display = 'block';
                    el.textContent = '0';
                } else {
                    el.style.display = 'none';
                }
            });
            
            totalEl.classList.remove('show');
        }
        
        function startPowerCharge() {
            if (isRolling) return;
            
            powerMeter.style.display = 'block';
            powerCharge = 0;
            powerLevel.style.width = '0%';
            
            powerChargeInterval = setInterval(() => {
                if (powerCharge < 100) {
                    powerCharge += 2;
                    powerLevel.style.width = powerCharge + '%';
                    
                    if (powerCharge < 33) {
                        powerLevel.style.background = 'linear-gradient(90deg, #4e54c8, #8f94fb)';
                    } else if (powerCharge < 66) {
                        powerLevel.style.background = 'linear-gradient(90deg, #8f94fb, #ff8a00)';
                    } else {
                        powerLevel.style.background = 'linear-gradient(90deg, #ff8a00, #ff416c)';
                    }
                }
            }, 20);
        }
        
        function stopPowerCharge() {
            if (!powerChargeInterval) return;
            clearInterval(powerChargeInterval);
            powerMeter.style.display = 'none';
            rollDice();
        }
        
        function rollDice() {
            if (isRolling) return;
            
            isRolling = true;
            throwButton.disabled = true;
            results = [];
            
            const dieResults = document.querySelectorAll('.die-result');
            dieResults.forEach(el => {
                if (el.style.display !== 'none') {
                    el.classList.remove('pop');
                    el.style.opacity = 0;
                    el.textContent = '0';
                }
            });
            totalEl.classList.remove('show');
            
            const powerMultiplier = 1 + (powerCharge / 100);
            
            dice.forEach((die, i) => {
                const radius = diceCount === 1 ? 0 : 3;
                const angle = (i / diceCount) * Math.PI * 2;
                die.body.position.set(
                    Math.cos(angle) * radius,
                    5 + Math.random() * 2,
                    Math.sin(angle) * radius
                );
                
                die.body.velocity.set(0, 0, 0);
                die.body.angularVelocity.set(0, 0, 0);
                
                die.body.quaternion.setFromEuler(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                die.body.applyImpulse(
                    new CANNON.Vec3(
                        (Math.random() - 0.5) * 10 * powerMultiplier,
                        (Math.random() * 8 + 8) * powerMultiplier,
                        (Math.random() - 0.5) * 10 * powerMultiplier
                    ),
                    new CANNON.Vec3(0, 0, 0)
                );
                
                die.body.applyTorque(
                    new CANNON.Vec3(
                        (Math.random() - 0.5) * 15 * powerMultiplier,
                        (Math.random() - 0.5) * 15 * powerMultiplier,
                        (Math.random() - 0.5) * 15 * powerMultiplier
                    )
                );
            });
            
            totalRolls++;
            totalDiceRolled += diceCount;
            totalRollsEl.textContent = totalRolls;
            totalDiceEl.textContent = totalDiceRolled;
        }
        
        function getTopFace(die) {
            const faceNormals = [
                new CANNON.Vec3(1, 0, 0),  
                new CANNON.Vec3(-1, 0, 0), 
                new CANNON.Vec3(0, 1, 0),   
                new CANNON.Vec3(0, -1, 0),  
                new CANNON.Vec3(0, 0, 1),   
                new CANNON.Vec3(0, 0, -1)  
            ];
            
            const faceNumbers = [1, 6, 2, 5, 3, 4];
            
            const worldUp = new CANNON.Vec3(0, 1, 0);
            
            let maxDot = -Infinity;
            let topFace = 0;
            
            for (let i = 0; i < faceNormals.length; i++) {
                const normal = faceNormals[i];
                const worldNormal = die.body.vectorToWorldFrame(normal);
                const dot = worldNormal.dot(worldUp);
                
                if (dot > maxDot) {
                    maxDot = dot;
                    topFace = i;
                }
            }
            
            return faceNumbers[topFace];
        }
        
        function diceSettled() {
            return dice.every(die => {
                return (
                    Math.abs(die.body.velocity.x) < 0.08 &&
                    Math.abs(die.body.velocity.y) < 0.08 &&
                    Math.abs(die.body.velocity.z) < 0.08 &&
                    Math.abs(die.body.angularVelocity.x) < 0.08 &&
                    Math.abs(die.body.angularVelocity.y) < 0.08 &&
                    Math.abs(die.body.angularVelocity.z) < 0.08
                );
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            world.step(1/60);
            
            dice.forEach(die => {
                die.mesh.position.copy(die.body.position);
                die.mesh.quaternion.copy(die.body.quaternion);
            });
            
            if (butterflies) {
                const time = Date.now() * 0.001;
                butterflies.children.forEach((butterfly, i) => {
                    butterfly.rotation.y = time * 0.5;
                    butterfly.position.y = -2 + Math.sin(time * 0.5 + i) * 2;
                    butterfly.position.x += Math.sin(time + i) * 0.02;
                    butterfly.position.z += Math.cos(time + i) * 0.02;
                });
            }
            
            if (isRolling && diceSettled()) {
                isRolling = false;
                throwButton.disabled = false;
                
                results = dice.map(die => getTopFace(die));
                const total = results.reduce((sum, val) => sum + val, 0);
                
                const dieResults = document.querySelectorAll('.die-result');
                dieResults.forEach((el, i) => {
                    if (i < diceCount) {
                        el.textContent = results[i];
                        setTimeout(() => {
                            el.classList.add('pop');
                        }, i * 200);
                    }
                });
                
                totalValueEl.textContent = total;
                setTimeout(() => {
                    totalEl.classList.add('show');
                }, results.length * 200);
                
                if (total > highestRoll) {
                    highestRoll = total;
                    highestRollEl.textContent = highestRoll;
                }
                
                totalRollSum += total;
                const average = totalRolls > 0 ? (totalRollSum / totalRolls) : 0;
                averageRollEl.textContent = average.toFixed(2);
            }
            
            const time = Date.now() * 0.0003;
            camera.position.x = Math.sin(time) * 15;
            camera.position.z = Math.cos(time) * 15;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        throwButton.addEventListener('click', rollDice);
        
        resetButton.addEventListener('click', () => {
            totalRolls = 0;
            totalDiceRolled = 0;
            highestRoll = 0;
            totalRollSum = 0;
            totalRollsEl.textContent = '0';
            totalDiceEl.textContent = '0';
            highestRollEl.textContent = '0';
            averageRollEl.textContent = '0';
        });
        
        diceCountEl.addEventListener('change', () => {
            diceCount = parseInt(diceCountEl.value);
            initDice();
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if (!isRolling) {
                    startPowerCharge();
                }
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && !isRolling) {
                stopPowerCharge();
            }
        });
        
        toggleUiBtn.addEventListener('click', () => {
            document.getElementById('ui-container').classList.toggle('open');
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        createEndlessGrass();
        createSky();
        createMountains();
        butterflies = createButterflies();
        setupLighting();
        initDice();
        animate();
    </script>
</body>
</html>
